# Simulator scenario 1: Registry reconnaissance and initial ROA creation 

## High‑level objective

Before attempting any prefix hijack, understand and establish legitimacy in the RPKI system. That means:

1.  Discover existing RPKI ROAs  for the target prefix
2.  Create a legitimate ROA for a prefix you control 
3.  Document the baseline  so defenders (and your SIEM) see this as “normal” activity

Why this matters:

* Later stages exploit weaknesses in RPKI validation
* But without first establishing legitimacy, later hijacks look suspicious
* So playbook 1 is about *laying the groundwork* without triggering alerts or suspicion
  This is a *control‑plane attack strategy* — not merely announcing forged prefixes, but shaping the validation infrastructure that tells routers what is “valid.” ([purple.tymyrddin.dev][1])

Key narrative:

*“RPKI ROAs are meant to be the truth that routers check announcements against. If we can manipulate ROAs, we redefine 
what ‘valid’ means.”*

This is different from a normal BGP hijack. It is a control‑plane preparation that makes later hijacks look valid.

## Turning playbook 1 into a simulator scenario

Below is a suggested  scenario definition (YAML)  and  telemetry mapping  you can drop into the simulator. This is based on the *essence* of Playbook 1, boiled down to what matters for your simulator:

##  Simulator scenario 

```yaml
id: playbook1
name: "RPKI Reconnaissance and ROA Creation"
description: |
  Control-plane attack preparation: Registry reconnaissance, legitimate ROA creation,
  and baseline establishment before ROA poisoning. This is phase 1 of a 3-part chain
  that poisons RPKI validation rather than bypassing it.
  
  Timeline simulates:
  - Action 1.1: RPKI infrastructure reconnaissance for target prefix
  - Action 1.2: Create legitimate ROA for our own prefix  
  - Action 1.3: Baseline documentation and verification
  
  Key insight: This is preparation, not attack. No hijack occurs in phase 1.
  The attack happens in playbook 3 after RPKI validation is compromised.

timeline:
  # === BASELINE: Target prefix operating normally ===
  - t: 0
    action: baseline_announcement
    prefix: "203.0.113.0/24"
    as_path: [65001, 65002, 65003]
    origin_as: 65003
    next_hop: "198.51.100.1"
    peer_ip: "198.51.100.1"
    peer_as: 65001
    peer_bgp_id: "198.51.100.1"
    communities: ["65003:100"]
    attack_step: "baseline"
    note: "Victim AS65003 legitimately announces their allocated prefix"

  # === ACTION 1.1: RPKI Infrastructure Reconnaissance ===
  - t: 60
    action: rpki_query
    prefix: "203.0.113.0/24"
    origin_as: 65003
    query_type: "ripe_stat_rpki_validation"
    query_source: "https://stat.ripe.net/data/rpki-validation/data.json"
    attack_step: "reconnaissance"
    note: "Query RIPE Stat to check if victim has deployed RPKI ROAs"

  - t: 65
    action: rpki_validation_result
    prefix: "203.0.113.0/24"
    origin_as: 65003
    rpki_state: "not_found"
    roa_exists: false
    attack_step: "reconnaissance"
    note: "Discovery: No ROA exists for target prefix (victim hasn't deployed RPKI)"

  - t: 70
    action: whois_query
    prefix: "203.0.113.0/24"
    registry: "ARIN"
    allocated_to: "AS65003"
    attack_step: "reconnaissance"
    note: "WHOIS query to identify RIR managing the allocation"

  - t: 120
    action: validator_query
    prefix: "203.0.113.0/24"
    validator: "routinator"
    result: "no_roa_found"
    attack_step: "reconnaissance"
    note: "Cross-check with local Routinator validator"

  # === ACTION 1.2: Create Legitimate ROA for Our Own Prefix ===
  - t: 300
    action: roa_creation_request
    prefix: "198.51.100.0/24"
    origin_as: 64513
    max_length: 25
    registry: "RIPE"
    actor: "operator@attacker-as64513.net"
    attack_step: "establish_presence"
    note: "Submit ROA creation via RIPE hosted RPKI service for our legitimate allocation"

  - t: 360
    action: roa_accepted
    prefix: "198.51.100.0/24"
    origin_as: 64513
    max_length: 25
    registry: "RIPE"
    attack_step: "establish_presence"
    note: "RIPE accepts ROA creation request (typically instant)"

  # === ROA Publication Lag (15-45 minutes typical) ===
  - t: 1500
    action: roa_published
    prefix: "198.51.100.0/24"
    origin_as: 64513
    max_length: 25
    trust_anchor: "ripe"
    repository_url: "rsync://rpki.ripe.net/repository/"
    attack_step: "establish_presence"
    note: "ROA appears in RIPE's RPKI repository (20-minute publication cycle)"

  - t: 1800
    action: validator_sync
    prefix: "198.51.100.0/24"
    validator: "routinator"
    rpki_state: "valid"
    attack_step: "establish_presence"
    note: "Routinator polls RIPE repository and sees our new ROA"

  - t: 1850
    action: validator_sync
    prefix: "198.51.100.0/24"
    validator: "fort"
    rpki_state: "valid"
    attack_step: "establish_presence"
    note: "FORT validator also sees our ROA (different polling schedule)"

  - t: 1900
    action: validator_sync
    prefix: "198.51.100.0/24"
    validator: "cloudflare"
    rpki_state: "valid"
    attack_step: "establish_presence"
    note: "Cloudflare's validator confirms ROA visibility"

  # === Our legitimate BGP announcement (now with RPKI validation) ===
  - t: 2000
    action: baseline_announcement
    prefix: "198.51.100.0/24"
    as_path: [65001, 64513]
    origin_as: 64513
    next_hop: "198.51.100.254"
    peer_ip: "198.51.100.2"
    peer_as: 65001
    peer_bgp_id: "198.51.100.2"
    rpki_state: "valid"
    attack_step: "establish_presence"
    note: "Our announcement now validates as VALID against our ROA"

  # === ACTION 1.3: Baseline Documentation ===
  - t: 2100
    action: baseline_documented
    target_prefix: "203.0.113.0/24"
    target_as: 65003
    target_roa_status: "not_found"
    our_prefix: "198.51.100.0/24"
    our_as: 64513
    our_roa_status: "published_and_validated"
    validators_checked: ["routinator", "fort", "cloudflare"]
    publication_lag_observed: 1500
    attack_step: "documentation"
    note: "Baseline complete: Target has no RPKI, we have legitimate presence"

  # === PHASE 1 COMPLETE - 7 DAY WAIT (compressed to 5 minutes for simulation) ===
  - t: 2400
    action: waiting_period_complete
    days_elapsed: 7
    attack_step: "operational_cover"
    note: "7-day waiting period establishes us as normal long-term RPKI participant (compressed for simulation)"

  # === Verification: Target status unchanged ===
  - t: 2460
    action: rpki_query
    prefix: "203.0.113.0/24"
    origin_as: 65003
    rpki_state: "not_found"
    attack_step: "verification"
    note: "Re-verify target still has no ROA (unchanged baseline)"

  - t: 2520
    action: phase1_complete
    attack_step: "completion"
    note: "Phase 1 success criteria met. Ready for Phase 2 (ROA expansion)"
```

 Why these three events? 

* `rpki_recon` → a reconnaissance lookup of ROA state
* `create_roa` → actually creating your own RPKI ROA
* `baseline_log` → produce logs that document the status quo

These map to the *three phase‑1 actions* described in the playbook.

##  Telemetry for playbook 1

This mapping script decides *what telemetry to emit* for each type of event in `scenario.yaml`.

```python
"""
Telemetry mapping for Playbook 1: RPKI Reconnaissance and ROA Creation.

Control-plane attack preparation showing:
- RPKI infrastructure reconnaissance (Action 1.1)
- Legitimate ROA creation and publication (Action 1.2)
- Baseline documentation (Action 1.3)

This playbook generates realistic multi-source telemetry for each action,
demonstrating what defenders would see during the reconnaissance phase.
"""
"""
Telemetry mapping for Playbook 3: Prefix Hijacking with RPKI Validation Cover.

Control-plane attack execution showing:
- Sub-prefix hijack announcement that validates as RPKI VALID (Action 3.1)
- Traffic interception verification (Action 3.2)
- Service forwarding to maintain availability (Action 3.3)
- Operational monitoring during active hijack (Action 3.4)
- Controlled withdrawal (Action 3.5)

This is the payoff: validators endorse our hijack as legitimate because we
poisoned the validation infrastructure in phases 1-2.
"""

from typing import Any
from simulator.engine.event_bus import EventBus
from simulator.engine.clock import SimulationClock
from telemetry.generators.bmp_telemetry import BMPTelemetryGenerator
from telemetry.generators.router_syslog import RouterSyslogGenerator


def register(event_bus: EventBus, clock: SimulationClock, scenario_name: str) -> None:
    """Register telemetry generators for Playbook 3 scenario."""

    bmp_gen = BMPTelemetryGenerator(
        scenario_id=scenario_name,
        scenario_name="Playbook 3: Prefix Hijacking with RPKI Validation Cover",
        clock=clock,
        event_bus=event_bus
    )

    syslog_gen = RouterSyslogGenerator(
        clock=clock,
        event_bus=event_bus,
        router_name="edge-router-01",
        scenario_name=scenario_name
    )

    def on_timeline_event(event: dict[str, Any]) -> None:
        """Map scenario timeline events to appropriate telemetry sources."""
        entry = event.get("entry")
        if not entry:
            return

        action = entry.get("action")
        prefix = entry.get("prefix", entry.get("hijacked_prefix", "unknown"))
        attack_step = entry.get("attack_step", "unknown")
        incident_id = f"{scenario_name}-{prefix}-{attack_step}"

        # === PHASE 2 RECAP ===

        if action == "phase2_complete":
            event_bus.publish({
                "event_type": "internal.phase_transition",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "phase": "phase_2_complete",
                    "fraudulent_roa_prefix": entry.get("fraudulent_roa_prefix"),
                    "target_region": entry.get("target_region")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === ACTION 3.1: Hijack Announcement ===

        elif action == "hijack_announcement":
            # BMP RouteMonitoring message showing the hijack
            bmp_event = {
                "prefix": prefix,
                "as_path": entry.get("as_path", []),
                "origin_as": entry.get("origin_as"),
                "next_hop": entry.get("next_hop"),
                "peer_ip": entry.get("peer_ip"),
                "peer_as": entry.get("peer_as"),
                "peer_bgp_id": entry.get("peer_bgp_id"),
                "communities": entry.get("communities", []),
                "rpki_state": entry.get("rpki_state"),
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            }
            bmp_gen.generate(bmp_event)

            # Realistic syslog message (no "HIJACK" label)
            syslog_gen.emit(
                message=f"BGP announcement: {prefix} from AS{entry.get('origin_as')}, RPKI validation: {entry.get('rpki_state')}",
                severity="info",
                subsystem="bgp",
                scenario={
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            )

        elif action == "announcement_propagation":
            event_bus.publish({
                "event_type": "bgp.propagation",
                "timestamp": clock.now(),
                "source": {"feed": "bgp-monitor", "observer": "route-collector"},
                "attributes": {
                    "prefix": prefix,
                    "propagation_status": entry.get("propagation_status"),
                    "peers_accepting": entry.get("peers_accepting"),
                    "peers_total": entry.get("peers_total")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "rpki_validation_check":
            # RPKI validation returns VALID - control-plane attack succeeding
            event_bus.publish({
                "event_type": "rpki.validation",
                "timestamp": clock.now(),
                "source": {"feed": "rpki-validator", "observer": entry.get("validator", "routinator")},
                "attributes": {
                    "prefix": prefix,
                    "origin_as": entry.get("origin_as"),
                    "validation_state": entry.get("validation_result"),
                    "validator": entry.get("validator")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

            # Realistic syslog message (no "FRAUDULENT" label)
            syslog_gen.emit(
                message=f"RPKI validation: {prefix} AS{entry.get('origin_as')} -> {entry.get('validation_result')} ({entry.get('validator')})",
                severity="info",
                subsystem="rpki",
                scenario={
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            )

        # === ACTION 3.2: Traffic Interception Verification ===

        elif action == "traffic_interception_test":
            event_bus.publish({
                "event_type": "network.traceroute",
                "timestamp": clock.now(),
                "source": {"feed": "test-infrastructure", "observer": entry.get("test_source")},
                "attributes": {
                    "destination": entry.get("destination"),
                    "via_as": entry.get("via_as"),
                    "result": entry.get("result"),
                    "test_source": entry.get("test_source")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "interception_summary":
            event_bus.publish({
                "event_type": "internal.analysis",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "regions_intercepted": entry.get("regions_intercepted", []),
                    "regions_not_intercepted": entry.get("regions_not_intercepted", []),
                    "interception_percentage": entry.get("interception_percentage")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === ACTION 3.3: Service Forwarding ===

        elif action == "forwarding_established":
            syslog_gen.emit(
                message=f"Traffic forwarding established for {entry.get('hijacked_prefix')} -> {entry.get('forward_to')} (method: {entry.get('forward_method')})",
                severity="warning",
                subsystem="routing",
                scenario={
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            )

        elif action == "service_continuity_verified":
            event_bus.publish({
                "event_type": "internal.service_check",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "hijacked_prefix": entry.get("hijacked_prefix"),
                    "services_functional": entry.get("services_functional"),
                    "added_latency_ms": entry.get("added_latency_ms"),
                    "packet_loss_increase": entry.get("packet_loss_increase")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "victim_traffic_analysis":
            # Victim's perspective - HIGH DETECTION RISK
            event_bus.publish({
                "event_type": "netflow.analysis",
                "timestamp": clock.now(),
                "source": {"feed": "netflow-collector", "observer": "victim-network"},
                "attributes": {
                    "prefix": entry.get("victim_prefix"),
                    "traffic_volume_drop_pct": entry.get("traffic_volume_drop_pct"),
                    "source_ip_changes": entry.get("source_ip_changes"),
                    "source_as_changed_to": entry.get("source_as_changed_to")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === ACTION 3.4: Operational Monitoring ===

        elif action == "hijack_monitoring_start":
            event_bus.publish({
                "event_type": "internal.monitoring_start",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "monitor_roa_status": entry.get("monitor_roa_status"),
                    "monitor_bgp_stability": entry.get("monitor_bgp_stability"),
                    "monitor_abuse_complaints": entry.get("monitor_abuse_complaints"),
                    "check_interval": entry.get("check_interval")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "monitoring_check":
            event_bus.publish({
                "event_type": "internal.monitoring_status",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "roa_status": entry.get("roa_status"),
                    "bgp_announcement": entry.get("bgp_announcement"),
                    "abuse_complaints": entry.get("abuse_complaints"),
                    "public_monitoring_alerts": entry.get("public_monitoring_alerts"),
                    "victim_investigation": entry.get("victim_investigation", False)
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "objective_achieved":
            event_bus.publish({
                "event_type": "internal.objective_complete",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "duration_minutes": entry.get("duration_minutes"),
                    "traffic_intercepted_gb": entry.get("traffic_intercepted_gb"),
                    "services_monitored": entry.get("services_monitored")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === ACTION 3.5: Controlled Withdrawal ===

        elif action == "withdrawal_decision":
            event_bus.publish({
                "event_type": "internal.withdrawal_decision",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "reason": entry.get("reason"),
                    "withdrawal_timing": entry.get("withdrawal_timing"),
                    "cover_story": entry.get("cover_story")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "withdrawal_announcement":
            # BGP WITHDRAW message
            bmp_event = {
                "prefix": prefix,
                "as_path": entry.get("as_path", [65001, entry.get("origin_as")]),
                "origin_as": entry.get("origin_as"),
                "next_hop": "198.51.100.254",
                "peer_ip": "198.51.100.1",
                "peer_as": 65001,
                "peer_bgp_id": "198.51.100.1",
                "is_withdraw": True,
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            }
            bmp_gen.generate(bmp_event)

            # Realistic syslog message (no "hijack ending" label)
            syslog_gen.emit(
                message=f"BGP withdrawal: {prefix} from AS{entry.get('origin_as')}",
                severity="notice",
                subsystem="bgp",
                scenario={
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            )

        elif action == "withdrawal_propagation":
            event_bus.publish({
                "event_type": "bgp.withdrawal_complete",
                "timestamp": clock.now(),
                "source": {"feed": "bgp-monitor", "observer": "route-collector"},
                "attributes": {
                    "prefix": prefix,
                    "withdrawal_status": entry.get("withdrawal_status"),
                    "peers_removed": entry.get("peers_removed")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "traffic_reconvergence":
            event_bus.publish({
                "event_type": "bgp.reconvergence",
                "timestamp": clock.now(),
                "source": {"feed": "bgp-monitor", "observer": "route-collector"},
                "attributes": {
                    "prefix": prefix,
                    "legitimate_path_restored": entry.get("legitimate_path_restored"),
                    "via_as": entry.get("via_as"),
                    "reconvergence_time_seconds": entry.get("reconvergence_time_seconds")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "victim_service_restored":
            event_bus.publish({
                "event_type": "netflow.normal",
                "timestamp": clock.now(),
                "source": {"feed": "netflow-collector", "observer": "victim-network"},
                "attributes": {
                    "prefix": prefix,
                    "traffic_volume_normal": entry.get("traffic_volume_normal"),
                    "source_as_normal": entry.get("source_as_normal")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === Post-Operation Assessment ===

        elif action == "hijack_evidence_assessment":
            event_bus.publish({
                "event_type": "internal.evidence_assessment",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "bgp_historical_data": entry.get("bgp_historical_data"),
                    "netflow_historical_data": entry.get("netflow_historical_data"),
                    "rpki_audit_trail": entry.get("rpki_audit_trail"),
                    "fraudulent_roa_status": entry.get("fraudulent_roa_status")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        elif action == "cleanup_decision":
            event_bus.publish({
                "event_type": "internal.cleanup_plan",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "fraudulent_roa_action": entry.get("fraudulent_roa_action"),
                    "cover_story": entry.get("cover_story"),
                    "revocation_timing": entry.get("revocation_timing")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

        # === PHASE 3 COMPLETE ===

        elif action == "phase3_complete":
            event_bus.publish({
                "event_type": "internal.phase_complete",
                "timestamp": clock.now(),
                "source": {"feed": "operator", "observer": "attack-team"},
                "attributes": {
                    "phase": "phase_3",
                    "hijack_duration_minutes": entry.get("hijack_duration_minutes"),
                    "traffic_intercepted": entry.get("traffic_intercepted"),
                    "rpki_validation_status": entry.get("rpki_validation_status"),
                    "control_plane_attack_confirmed": entry.get("control_plane_attack_confirmed"),
                    "detection_during_operation": entry.get("detection_during_operation"),
                    "withdrawal_clean": entry.get("withdrawal_clean")
                },
                "scenario": {
                    "name": scenario_name,
                    "attack_step": attack_step,
                    "incident_id": incident_id
                }
            })

    # Subscribe to all timeline events
    event_bus.subscribe(on_timeline_event)
```

This mirrors *Phase 1 actions* without making anything malicious.


## Expected output

When you run:

```bash
python -m simulator.cli simulator/scenarios/easy/playbook1/scenario.yaml --mode practice --output cli
```

Your SIEM could see logs like (if it is edible):

```
Jan 01 00:01:00 tacacs-server admin@victim-network.net login from 185.220.101.45
<29>Jan 01 00:02:00 ARIN ROA creation request: 203.0.113.0/24 origin AS64513 maxLength /25 by admin@victim-network.net via ARIN
<10>Jan 01 00:02:00 edge-router-01 ROA creation request for 203.0.113.0/24 (origin AS64513, maxLength /25) - FRAUDULENT
<30>Jan 01 00:03:00 ARIN RPKI validation: 203.0.113.0/24 origin ASNone -> unknown
<10>Jan 01 00:04:00 edge-router-01 ROA creation accepted for 203.0.113.0/24 by ARIN - ATTACK SUCCEEDING
<30>Jan 01 00:40:00 arin ROA published: 203.0.113.0/24 origin AS64513 in arin repository
<10>Jan 01 00:40:00 edge-router-01 FRAUDULENT ROA published for 203.0.113.0/24 in arin repository
<30>Jan 01 00:45:00 routinator Validator sync: routinator sees 203.0.113.0/24 as valid
<30>Jan 01 00:46:00 cloudflare Validator sync: cloudflare sees 203.0.113.0/24 as valid
<30>Jan 01 00:47:00 ripe Validator sync: ripe sees 203.0.113.0/24 as valid
BMP ROUTE: prefix 198.51.100.0/24 AS_PATH [65001, 64514] NEXT_HOP 198.51.100.254 ORIGIN_AS 64514
{"event_type":"bmp_route_monitoring","timestamp":3060,"source":{"feed":"bmp-collector","observer":"collector-01"},"peer_header":{"peer_type":0,"peer_address":"198.51.100.1","peer_as":65001,"peer_bgp_id":"198.51.100.1","timestamp_seconds":3060,"timestamp_microseconds":0},"bgp_update":{"prefix":"198.51.100.0/24","prefix_length":24,"afi":1,"safi":1,"is_withdraw":false,"as_path":[65001,64514],"origin_as":64514,"next_hop":"198.51.100.254","origin":"IGP"},"rpki_validation":{"state":"invalid","validation_timestamp":3060}}
<13>Jan 01 00:51:00 edge-router-01 Validation test AMER: Announcement 198.51.100.0/24 AS64514 - peer rejected
BMP ROUTE: prefix 198.51.100.0/24 AS_PATH [65001, 64514] NEXT_HOP 198.51.100.254 ORIGIN_AS 64514
{"event_type":"bmp_route_monitoring","timestamp":3120,"source":{"feed":"bmp-collector","observer":"collector-01"},"peer_header":{"peer_type":0,"peer_address":"198.51.100.1","peer_as":65001,"peer_bgp_id":"198.51.100.1","timestamp_seconds":3120,"timestamp_microseconds":0},"bgp_update":{"prefix":"198.51.100.0/24","prefix_length":24,"afi":1,"safi":1,"is_withdraw":false,"as_path":[65001,64514],"origin_as":64514,"next_hop":"198.51.100.254","origin":"IGP"},"rpki_validation":{"state":"invalid","validation_timestamp":3120}}
<13>Jan 01 00:52:00 edge-router-01 Validation test EMEA: Announcement 198.51.100.0/24 AS64514 - peer accepted
BMP ROUTE: prefix 198.51.100.0/24 AS_PATH [65001, 64514] NEXT_HOP 198.51.100.254 ORIGIN_AS 64514
{"event_type":"bmp_route_monitoring","timestamp":3180,"source":{"feed":"bmp-collector","observer":"collector-01"},"peer_header":{"peer_type":0,"peer_address":"198.51.100.1","peer_as":65001,"peer_bgp_id":"198.51.100.1","timestamp_seconds":3180,"timestamp_microseconds":0},"bgp_update":{"prefix":"198.51.100.0/24","prefix_length":24,"afi":1,"safi":1,"is_withdraw":false,"as_path":[65001,64514],"origin_as":64514,"next_hop":"198.51.100.254","origin":"IGP"},"rpki_validation":{"state":"invalid","validation_timestamp":3180}}
<13>Jan 01 00:53:00 edge-router-01 Validation test APAC: Announcement 198.51.100.0/24 AS64514 - peer mixed
BMP ROUTE: prefix 198.51.100.0/24 AS_PATH [65001, 64514] NEXT_HOP 198.51.100.254 ORIGIN_AS 64514
{"event_type":"bmp_route_monitoring","timestamp":3240,"source":{"feed":"bmp-collector","observer":"collector-01"},"peer_header":{"peer_type":0,"peer_address":"198.51.100.1","peer_as":65001,"peer_bgp_id":"198.51.100.1","timestamp_seconds":3240,"timestamp_microseconds":0},"bgp_update":{"prefix":"198.51.100.0/24","prefix_length":24,"afi":1,"safi":1,"is_withdraw":true,"as_path":[65001,64514],"origin_as":64514,"next_hop":"198.51.100.254","origin":"IGP"}}
```

These events together *create a believable baseline* before later playbooks alter RPKI and launch hijacks.

## Related

* [Playbook 1: Registry reconnaissance and initial ROA creation](../playbooks/1.md)
* [Simulator scenario 2: ROA scope expansion and validation environment mapping](2.md) 
* [Simulator scenario 3: Prefix hijacking with RPKI validation cover](3.md) 

